import React, { useState, useEffect, useCallback } from "react";
import {
  StyleSheet,
  View,
  Text,
  TextInput,
  TouchableOpacity,
  FlatList,
  ScrollView,
  SafeAreaView,
  Platform,
  KeyboardAvoidingView,
  Appearance, // Added to get system theme
} from "react-native";
import { Calendar, Agenda, LocaleConfig } from "react-native-calendars";
import { Button, Dialog, Portal, Provider as PaperProvider } from "react-native-paper"; // Added PaperProvider for theme context
import {
  format,
  isToday,
  isSameDay,
  isBefore,
  isAfter,
  parse,
  subDays, // Added subDays
} from "date-fns";
import {
  Calendar as CalendarIcon,
  CheckCircle,
  Clock,
  Moon,
  Sun,
  Plus,
  Trash2,
  Edit,
  ChevronDown, // Added for dropdown indication
} from "lucide-react-native"; // Using lucide-react-native
import { GestureHandlerRootView } from "react-native-gesture-handler";
import DateTimePicker from "@react-native-community/datetimepicker"; // Restored import
import { useSafeAreaInsets } from "react-native-safe-area-context";
import AsyncStorage from "@react-native-async-storage/async-storage";
// For UUIDs, crypto.randomUUID() is used. If issues arise on specific platforms/versions,
// consider using a library like 'react-native-uuid'.
// import uuid from 'react-native-uuid'; // Example: const newId = uuid.v4();

// Localization
LocaleConfig.locales["en"] = {
  monthNames: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December",
  ],
  monthNamesShort: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec",
  ],
  dayNames: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday",
  ],
  dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  today: "Today",
};
LocaleConfig.defaultLocale = "en";

const createDate = dateStrOrDate => {
  if (typeof dateStrOrDate === "string") {
    try {
      return parse(dateStrOrDate, "yyyy-MM-dd", new Date());
    } catch (error) {
      console.error("Error parsing date string:", dateStrOrDate, error);
      return new Date(); // Fallback to current date or handle error appropriately
    }
  }
  return dateStrOrDate; // Assume it's already a Date object
};

const TimePicker = ({ value, onChange, isDarkMode }) => {
  const [isPickerVisible, setIsPickerVisible] = useState(false);
  const [selectedTime, setSelectedTime] = useState(
    value ? parse(value, "HH:mm", new Date()) : new Date() // Default to now if no value
  );

  useEffect(() => {
    if (value) {
      try {
        setSelectedTime(parse(value, "HH:mm", new Date()));
      } catch (error) {
        console.error("Error parsing time value in TimePicker:", value, error);
        setSelectedTime(new Date()); // Fallback
      }
    } else {
      setSelectedTime(new Date()); // Reset to current time if value is cleared
    }
  }, [value]);

  const handleTimeChange = (_event, time) => {
    setIsPickerVisible(false);
    if (time) {
      setSelectedTime(time);
      onChange(format(time, "HH:mm"));
    }
  };

  return (
    <>
      <TouchableOpacity
        onPress={() => setIsPickerVisible(true)}
        style={[styles.timePickerButton, { borderColor: isDarkMode ? "#555" : "#ccc"}]}
      >
        <Text style={{ color: isDarkMode ? "#fff" : "#000" }}>
          {format(selectedTime, "HH:mm")}
        </Text>
      </TouchableOpacity>
      {isPickerVisible && (
        <DateTimePicker
          value={selectedTime}
          mode="time"
          is24Hour={true}
          display="default"
          onChange={handleTimeChange}
          textColor={isDarkMode ? "#FFFFFF" : "#000000"} // iOS specific
          style={{ backgroundColor: isDarkMode ? "#333333" : "#FFFFFF" }} // Android specific container styling
        />
      )}
    </>
  );
};

const availableColors = [
  "#FF6B6B", "#4ECDC4", "#45B7D1", "#FED766", "#2AB7CA",
  "#F0C419", "#FF8C42", "#FC9F5B", "#E27D60", "#8EE4AF",
  "#C38D9E", "#E8A87C", "#4A4E69", "#9A8C98", "#22223B"
];

const ColorPicker = ({ selectedColor, onSelectColor, isDarkMode }) => (
  <View style={styles.colorPickerContainer}>
    {availableColors.map(color => (
      <TouchableOpacity
        key={color}
        style={[
          styles.colorOption,
          { backgroundColor: color },
          selectedColor === color && styles.selectedColorOption,
          selectedColor === color && { borderColor: isDarkMode ? "#fff" : "#000" }
        ]}
        onPress={() => onSelectColor(color)}
      />
    ))}
  </View>
);

const SubjectInput = ({ subjects, selectedSubjectId, onSelect, onAdd, isDarkMode }) => {
  const [newSubjectName, setNewSubjectName] = useState("");
  const [isAddSubjectModalVisible, setAddSubjectModalVisible] = useState(false);
  const [isSubjectListDialogVisible, setIsSubjectListDialogVisible] = useState(false);
  const [selectedColorForNewSubject, setSelectedColorForNewSubject] = useState(availableColors[0]);

  const handleAddNewSubject = () => {
    if (newSubjectName.trim() === "") {
      alert("Subject name cannot be empty.");
      return;
    }
    const newSubject = {
      id: crypto.randomUUID(), // Or uuid.v4()
      name: newSubjectName.trim(),
      color: selectedColorForNewSubject,
    };
    onAdd(newSubject);
    setNewSubjectName("");
    setSelectedColorForNewSubject(availableColors[0]);
    setAddSubjectModalVisible(false);
  };

  const selectedSubject = subjects.find(s => s.id === selectedSubjectId);

  const styles = getDynamicStyles(isDarkMode, useSafeAreaInsets()); // For dynamic styling if needed within

  return (
    <>
      <View style={styles.inputGroup}>
        <Text style={styles.label}>Subject</Text>
        <View style={{ flexDirection: "row", alignItems: "center", gap: 8 }}>
          <TouchableOpacity
            onPress={() => setIsSubjectListDialogVisible(true)}
            style={[styles.subjectPickerButton, { flex: 1, borderColor: isDarkMode ? "#555" : "#ccc" }]}
          >
            <Text style={styles.subjectPickerText}>
              {selectedSubject ? selectedSubject.name : "Select Subject"}
            </Text>
            <ChevronDown size={20} color={isDarkMode ? "#fff" : "#000"} />
          </TouchableOpacity>
          <TouchableOpacity
            onPress={() => {
              setSelectedColorForNewSubject(availableColors[0]); // Reset color for new subject
              setAddSubjectModalVisible(true);
            }}
            style={styles.smallButton}
          >
            <Plus size={20} color={isDarkMode ? "#BB86FC" : "#6200ee"} />
          </TouchableOpacity>
        </View>
      </View>

      <Portal>
        {/* Dialog for Adding a New Subject */}
        <Dialog
          visible={isAddSubjectModalVisible}
          onDismiss={() => setAddSubjectModalVisible(false)}
          style={{ backgroundColor: isDarkMode ? "#1E1E1E" : "#fff" }}
        >
          <Dialog.Title style={styles.dialogTitle}>Add New Subject</Dialog.Title>
          <Dialog.Content>
            <TextInput
              placeholder="Subject Name"
              placeholderTextColor={isDarkMode ? "#888" : "#aaa"}
              value={newSubjectName}
              onChangeText={setNewSubjectName}
              style={styles.textInput}
            />
            <Text style={[styles.label, { marginTop: 10, marginBottom: 5 }]}>Subject Color</Text>
            <ColorPicker
              selectedColor={selectedColorForNewSubject}
              onSelectColor={setSelectedColorForNewSubject}
              isDarkMode={isDarkMode}
            />
          </Dialog.Content>
          <Dialog.Actions>
            <Button
              onPress={() => setAddSubjectModalVisible(false)}
              textColor={isDarkMode ? "#A0A0A0" : "#555555"}
            >
              Cancel
            </Button>
            <Button
              onPress={handleAddNewSubject}
              textColor={isDarkMode ? "#BB86FC" : "#6200ee"}
            >
              Add
            </Button>
          </Dialog.Actions>
        </Dialog>

        {/* Dialog for Selecting an Existing Subject */}
        <Dialog
          visible={isSubjectListDialogVisible}
          onDismiss={() => setIsSubjectListDialogVisible(false)}
          style={{ backgroundColor: isDarkMode ? "#1E1E1E" : "#fff" }}
        >
          <Dialog.Title style={styles.dialogTitle}>Select a Subject</Dialog.Title>
          <Dialog.Content>
            {subjects.length === 0 ? (
              <Text style={styles.emptyStateText}>No subjects available. Add one first!</Text>
            ) : (
              <FlatList
                data={subjects}
                keyExtractor={item => item.id}
                renderItem={({ item }) => (
                  <TouchableOpacity
                    style={[styles.subjectListItem, { borderBottomColor: isDarkMode ? "#333" : "#eee" }]}
                    onPress={() => {
                      onSelect(item.id);
                      setIsSubjectListDialogVisible(false);
                    }}
                  >
                    <View style={[styles.subjectColorDot, { backgroundColor: item.color }]} />
                    <Text style={styles.subjectListItemText}>{item.name}</Text>
                  </TouchableOpacity>
                )}
              />
            )}
          </Dialog.Content>
          <Dialog.Actions>
            <Button
              onPress={() => setIsSubjectListDialogVisible(false)}
              textColor={isDarkMode ? "#A0A0A0" : "#555555"}
            >
              Cancel
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </>
  );
};


const StudyPlannerApp = () => {
  const insets = useSafeAreaInsets();
  const [systemTheme, setSystemTheme] = useState(Appearance.getColorScheme());
  const [isDarkMode, setIsDarkMode] = useState(systemTheme === "dark");

  useEffect(() => {
    const subscription = Appearance.addChangeListener(({ colorScheme }) => {
      setSystemTheme(colorScheme);
      setIsDarkMode(colorScheme === "dark");
    });
    return () => subscription.remove();
  }, []);


  const [selectedDate, setSelectedDate] = useState(format(new Date(), "yyyy-MM-dd"));
  const [unnegotiables, setUnnegotiables] = useState([]);
  const [studySessions, setStudySessions] = useState([]);
  const [subjects, setSubjects] = useState([]);

  const [isAddUnnegotiableModalVisible, setAddUnnegotiableModalVisible] = useState(false);
  const [isAddSessionModalVisible, setAddSessionModalVisible] = useState(false);
  const [editingUnnegotiable, setEditingUnnegotiable] = useState(null);
  const [editingSession, setEditingSession] = useState(null);
  const [selectedSubjectId, setSelectedSubjectId] = useState(null); // For the session modal

  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [itemToDeleteId, setItemToDeleteId] = useState(null);
  const [itemToDeleteType, setItemToDeleteType] = useState(""); // 'unnegotiable' or 'session' or 'subject'

  // Load data from AsyncStorage
  useEffect(() => {
    const loadData = async () => {
      try {
        const unnegotiablesData = await AsyncStorage.getItem("unnegotiables");
        if (unnegotiablesData) setUnnegotiables(JSON.parse(unnegotiablesData));
        const studySessionsData = await AsyncStorage.getItem("studySessions");
        if (studySessionsData) setStudySessions(JSON.parse(studySessionsData));
        const subjectsData = await AsyncStorage.getItem("subjects");
        if (subjectsData) setSubjects(JSON.parse(subjectsData));
      } catch (e) {
        console.error("Failed to load data from AsyncStorage", e);
      }
    };
    loadData();
  }, []);

  // Save data to AsyncStorage
  useEffect(() => {
    const saveData = async () => {
      try {
        await AsyncStorage.setItem("unnegotiables", JSON.stringify(unnegotiables));
        await AsyncStorage.setItem("studySessions", JSON.stringify(studySessions));
        await AsyncStorage.setItem("subjects", JSON.stringify(subjects));
      } catch (e) {
        console.error("Failed to save data to AsyncStorage", e);
      }
    };
    saveData();
  }, [unnegotiables, studySessions, subjects]);


  const handleAddUnnegotiable = (formData) => {
    if (formData && formData.id) { // Editing existing
      setUnnegotiables(unnegotiables.map(u => (u.id === formData.id ? formData : u)));
    } else { // Adding new
      const newUnnegotiable = {
        id: crypto.randomUUID(), // Or uuid.v4()
        name: formData?.name || "New Commitment",
        days: formData?.days || [],
        startTime: formData?.startTime || "09:00",
        endTime: formData?.endTime || "17:00",
        color: formData?.color || availableColors[0],
      };
      setUnnegotiables(prev => [...prev, newUnnegotiable]);
    }
    setAddUnnegotiableModalVisible(false);
    setEditingUnnegotiable(null);
  };

  const handleAddSession = (formData) => {
    if (formData && formData.id) { // Editing existing
      setStudySessions(studySessions.map(s => (s.id === formData.id ? formData : s)));
    } else { // Adding new
      const subjectId = formData?.subject || (subjects.length > 0 ? subjects[0].id : null);
      const subjectForSession = subjects.find(s => s.id === subjectId);
      const defaultColor = subjectForSession ? subjectForSession.color : availableColors[1];

      const newSession = {
        id: crypto.randomUUID(), // Or uuid.v4()
        subject: subjectId,
        startTime: formData?.startTime || "10:00",
        endTime: formData?.endTime || "12:00",
        date: formData?.date || selectedDate,
        notes: formData?.notes || "",
        color: formData?.color || defaultColor,
      };
      setStudySessions(prev => [...prev, newSession]);
    }
    setAddSessionModalVisible(false);
    setEditingSession(null);
    setSelectedSubjectId(null);
  };

  const handleAddSubject = (newSubject) => {
    setSubjects(prev => [...prev, newSubject]);
    // If adding a session and this new subject should be selected
    if (isAddSessionModalVisible && editingSession) {
      setEditingSession(prev => ({ ...prev, subject: newSubject.id, color: newSubject.color }));
      setSelectedSubjectId(newSubject.id);
    }
  };

  const openDeleteDialog = (id, type) => {
    setItemToDeleteId(id);
    setItemToDeleteType(type);
    setShowDeleteDialog(true);
  };

  const handleDeleteItem = () => {
    if (itemToDeleteType === "unnegotiable") {
      setUnnegotiables(unnegotiables.filter(u => u.id !== itemToDeleteId));
    } else if (itemToDeleteType === "session") {
      setStudySessions(studySessions.filter(s => s.id !== itemToDeleteId));
    } else if (itemToDeleteType === "subject") {
      // Check if subject is in use
      const isSubjectInUse = studySessions.some(session => session.subject === itemToDeleteId);
      if (isSubjectInUse) {
        alert("Cannot delete subject. It is currently used in one or more study sessions.");
      } else {
        setSubjects(subjects.filter(s => s.id !== itemToDeleteId));
      }
    }
    setShowDeleteDialog(false);
    setItemToDeleteId(null);
    setItemToDeleteType("");
  };


  const onDayPress = day => {
    setSelectedDate(day.dateString);
  };

  const renderDay = (day, item) => {
    // 'day' from renderDay prop is a date object like {dateString, day, month, year, timestamp}
    // 'item' is undefined here, this function is for calendar cells
    const dayDate = createDate(day.dateString); // Ensure we have a Date object
    const styles = getDynamicStyles(isDarkMode, insets);

    return (
      <TouchableOpacity
        onPress={() => onDayPress(day)}
        style={[
          styles.calendarDay,
          isToday(dayDate) && styles.todayCell,
          isSameDay(dayDate, createDate(selectedDate)) && styles.selectedDayCell,
        ]}
      >
        <Text style={[
            styles.calendarDayText,
            isSameDay(dayDate, createDate(selectedDate)) && styles.selectedDayText,
            isToday(dayDate) && styles.todayText,
          ]}
        >
          {day.day}
        </Text>
        {/* Add dots for events */}
      </TouchableOpacity>
    );
  };

  const agendaItems = studySessions.reduce((acc, session) => {
    const date = session.date; // Already "yyyy-MM-dd"
    if (!acc[date]) {
      acc[date] = [];
    }
    acc[date].push({ ...session, height: 80 }); // Add height for agenda items
    return acc;
  }, {});

  const renderAgendaItem = (item, isFirst) => {
    const subject = subjects.find(s => s.id === item.subject);
    const subjectName = subject ? subject.name : "No Subject";
    const itemColor = item.color || (subject ? subject.color : availableColors[2]);
    const styles = getDynamicStyles(isDarkMode, insets);

    return (
      <TouchableOpacity
        style={[styles.agendaItem, { borderLeftColor: itemColor }]}
        onPress={() => {
          setEditingSession(item);
          setSelectedSubjectId(item.subject);
          setAddSessionModalVisible(true);
        }}
      >
        <View style={{ flex: 1 }}>
            <Text style={styles.agendaItemTime}>{`${item.startTime} - ${item.endTime}`}</Text>
            <Text style={styles.agendaItemSubject}>{subjectName}</Text>
            {item.notes && <Text style={styles.agendaItemNotes} numberOfLines={1}>{item.notes}</Text>}
        </View>
        <TouchableOpacity onPress={() => openDeleteDialog(item.id, "session")} style={styles.deleteIconAgenda}>
            <Trash2 size={18} color={isDarkMode ? "#FF7F7F" : "#D32F2F"} />
        </TouchableOpacity>
      </TouchableOpacity>
    );
  };


  const renderEmptyAgenda = () => {
    const styles = getDynamicStyles(isDarkMode, insets);
    return (
      <View style={styles.emptyAgendaContainer}>
        <Text style={styles.emptyAgendaText}>No study sessions for this day.</Text>
        <Button
            mode="contained"
            icon={() => <Plus size={18} color={isDarkMode ? "#000" : "#fff"} />}
            onPress={() => {
              const defaultSubjectId = subjects.length > 0 ? subjects[0].id : null;
              const defaultColor = subjects.length > 0 ? (subjects.find(s=>s.id === defaultSubjectId)?.color || availableColors[1]) : availableColors[1];
              setEditingSession({
                subject: defaultSubjectId,
                startTime: "10:00",
                endTime: "12:00",
                date: selectedDate,
                notes: "",
                color: defaultColor,
              });
              setSelectedSubjectId(defaultSubjectId);
              setAddSessionModalVisible(true);
            }}
            style={{ marginTop: 20 }}
            labelStyle={{ color: isDarkMode ? "#000" : "#fff" }}
            theme={{ colors: { primary: isDarkMode ? "#BB86FC" : "#6200ee" } }}
        >
            Add Session
        </Button>
      </View>
    );
  };

  // Dynamic styles for theme
  const styles = getDynamicStyles(isDarkMode, insets);
  const calendarTheme = {
    backgroundColor: isDarkMode ? "#121212" : "#ffffff",
    calendarBackground: isDarkMode ? "#1E1E1E" : "#ffffff",
    textSectionTitleColor: isDarkMode ? "#b6c1cd" : "#2d4150",
    selectedDayBackgroundColor: "#00adf5",
    selectedDayTextColor: "#ffffff",
    todayTextColor: isDarkMode ? "#00AAFF" : "#007AFF", // Brighter blue for today
    dayTextColor: isDarkMode ? "#D1D1D1" : "#2d4150",
    textDisabledColor: isDarkMode ? "#555555" : "#d9e1e8",
    dotColor: "#00adf5",
    selectedDotColor: "#ffffff",
    arrowColor: isDarkMode ? "#BB86FC" : "#6200ee",
    disabledArrowColor: isDarkMode ? "#555555" : "#d9e1e8",
    monthTextColor: isDarkMode ? "#E1E1E1" : "#2d4150",
    indicatorColor: "blue",
    textDayFontWeight: "300",
    textMonthFontWeight: "bold",
    textDayHeaderFontWeight: "300",
    textDayFontSize: 16,
    textMonthFontSize: 18,
    textDayHeaderFontSize: 14,
    agendaDayTextColor: isDarkMode ? "#BB86FC" : '#6200ee',
    agendaDayNumColor: isDarkMode ? "#BB86FC" : '#6200ee',
    agendaTodayColor: isDarkMode ? '#00AAFF' : '#007AFF',
    agendaKnobColor: isDarkMode ? "#BB86FC" : '#6200ee',
  };

  return (
    <PaperProvider>
      <GestureHandlerRootView style={{ flex: 1 }}>
        <SafeAreaView style={[styles.safeArea, { paddingTop: insets.top, paddingBottom: insets.bottom }]}>
          <KeyboardAvoidingView
            behavior={Platform.OS === "ios" ? "padding" : undefined} // "height" can sometimes cause issues
            style={{ flex: 1 }}
            keyboardVerticalOffset={Platform.OS === "ios" ? 64 : 0}
          >
            <View style={styles.container}>
              <View style={styles.header}>
                <Text style={styles.title}>Study Planner</Text>
                <TouchableOpacity onPress={() => setIsDarkMode(!isDarkMode)}>
                  {isDarkMode ? <Sun size={24} color="#FFD700" /> : <Moon size={24} color="#4A4A4A" />}
                </TouchableOpacity>
              </View>

            <ScrollView
                showsVerticalScrollIndicator={false}
                contentContainerStyle={{ paddingBottom: 100 }} // Ensure space for last items if Agenda is tall
            >
                <Calendar
                    current={selectedDate}
                    onDayPress={onDayPress}
                    monthFormat={"MMMM yyyy"}
                    theme={calendarTheme}
                    renderDay={renderDay} // Using custom renderDay
                    style={styles.calendar}
                    markedDates={{
                        [selectedDate]: { selected: true, selectedColor: calendarTheme.selectedDayBackgroundColor },
                        // Mark days with sessions
                        ...Object.keys(agendaItems).reduce((acc, date) => {
                            acc[date] = { ...acc[date], marked: true, dotColor: calendarTheme.dotColor };
                            return acc;
                        }, {}),
                    }}
                />

                <View style={styles.section}>
                    <Text style={styles.sectionTitle}>Unnegotiable Commitments</Text>
                    {unnegotiables.length === 0 ? (
                        <Text style={styles.emptyStateText}>No fixed commitments added yet.</Text>
                    ) : (
                    <FlatList
                        data={unnegotiables}
                        keyExtractor={item => item.id}
                        renderItem={({ item }) => (
                        <View style={[styles.listItem, { borderLeftColor: item.color || availableColors[0] }]}>
                            <View style={{ flex: 1 }}>
                            <Text style={styles.listItemText}>{item.name}</Text>
                            <Text style={styles.listItemSubText}>
                                {item.days.join(", ")} | {item.startTime} - {item.endTime}
                            </Text>
                            </View>
                            <TouchableOpacity onPress={() => { setEditingUnnegotiable(item); setAddUnnegotiableModalVisible(true); }} style={styles.editIcon}>
                                <Edit size={18} color={isDarkMode ? "#A0A0A0" : "#555555"} />
                            </TouchableOpacity>
                            <TouchableOpacity onPress={() => openDeleteDialog(item.id, "unnegotiable")} style={styles.deleteIcon}>
                                <Trash2 size={18} color={isDarkMode ? "#FF7F7F" : "#D32F2F"} />
                            </TouchableOpacity>
                        </View>
                        )}
                        // scrollEnabled={false} // If ScrollView parent should handle scrolling
                    />
                    )}
                    <Button
                        mode="outlined"
                        icon={() => <Plus size={18} color={isDarkMode ? "#BB86FC" : "#6200ee"} />}
                        onPress={() => {
                            setEditingUnnegotiable({ // Initialize for new entry
                                name: "",
                                days: [],
                                startTime: "09:00",
                                endTime: "17:00",
                                color: availableColors[0],
                            });
                            setAddUnnegotiableModalVisible(true);
                        }}
                        style={styles.addButton}
                        labelStyle={{ color: isDarkMode ? "#BB86FC" : "#6200ee" }}
                        theme={{ colors: { primary: isDarkMode ? "#BB86FC" : "#6200ee", outline: isDarkMode ? "#555" : "#ccc" } }}
                    >
                        Add Commitment
                    </Button>
                </View>

                <View style={styles.section}>
                    <Text style={styles.sectionTitle}>Subjects</Text>
                    {subjects.length === 0 ? (
                         <Text style={styles.emptyStateText}>No subjects added yet.</Text>
                    ) : (
                    <FlatList
                        data={subjects}
                        keyExtractor={item => item.id}
                        renderItem={({ item }) => (
                            <View style={[styles.listItem, { borderLeftColor: item.color || availableColors[0] }]}>
                                <View style={[styles.subjectColorDot, { backgroundColor: item.color, marginRight: 10 }]} />
                                <Text style={[styles.listItemText, {flex:1}]}>{item.name}</Text>
                                <TouchableOpacity onPress={() => openDeleteDialog(item.id, "subject")} style={styles.deleteIcon}>
                                    <Trash2 size={18} color={isDarkMode ? "#FF7F7F" : "#D32F2F"} />
                                </TouchableOpacity>
                            </View>
                        )}
                        // scrollEnabled={false}
                    />
                    )}
                    <Button
                        mode="outlined"
                        icon={() => <Plus size={18} color={isDarkMode ? "#BB86FC" : "#6200ee"} />}
                        onPress={() => { // Trigger SubjectInput's add new mechanism indirectly
                            // This might need SubjectInput to expose a method or handle this via a prop
                            // For now, we rely on the SubjectInput in the Session Modal.
                            // Or, provide a standalone "Add Subject" here.
                            // Let's use the SubjectInput modal directly for adding for now.
                            // This requires a modal just for subject adding or integrate SubjectInput here.
                            // For simplicity, if adding here, we'd need a separate mini-form for subject.
                            // The existing SubjectInput component is designed to be part of other forms.
                            // A simpler approach for this button:
                            alert("Add subjects via the 'Add Study Session' form or edit an existing session.");
                            // Or, implement a simpler add subject modal here if desired.
                        }}
                        style={styles.addButton}
                        labelStyle={{ color: isDarkMode ? "#BB86FC" : "#6200ee" }}
                        theme={{ colors: { primary: isDarkMode ? "#BB86FC" : "#6200ee", outline: isDarkMode ? "#555" : "#ccc" } }}
                    >
                        Add Subject
                    </Button>
                </View>


                {/* Study Sessions are primarily handled by Agenda */}
                <View style={styles.section}>
                    <Text style={styles.sectionTitle}>Daily Study Plan</Text>
                </View>
            </ScrollView>
            </View>

            <Agenda
                items={agendaItems}
                selected={selectedDate}
                onDayPress={onDayPress} // Allow changing day from Agenda header
                renderItem={renderAgendaItem}
                renderEmptyData={renderEmptyAgenda}
                showClosingKnob={true}
                theme={calendarTheme}
                style={{ height: Platform.OS === 'android' ? 400 : 350 }} // Give Agenda a fixed height or flex grow.
                // futureScrollRange={12}
                // pastScrollRange={3}
            />


            {/* Add Study Session Floating Action Button or Button */}
             <Button
                mode="contained"
                icon={() => <Plus size={20} color={isDarkMode ? "#000" : "#fff"} />}
                onPress={() => {
                    const defaultSubjectId = subjects.length > 0 ? subjects[0].id : null;
                    const defaultColor = subjects.length > 0 ? (subjects.find(s=>s.id === defaultSubjectId)?.color || availableColors[1]) : availableColors[1];

                    setEditingSession({ // Initialize for new session
                        subject: defaultSubjectId,
                        startTime: "10:00",
                        endTime: "12:00",
                        date: selectedDate, // Use current calendar date
                        notes: "",
                        color: defaultColor,
                    });
                    setSelectedSubjectId(defaultSubjectId);
                    setAddSessionModalVisible(true);
                }}
                style={styles.fab}
                labelStyle={{ color: isDarkMode ? "#000" : "#fff" }}
                theme={{ colors: { primary: isDarkMode ? "#BB86FC" : "#6200ee" } }}
            >
                New Study Session
            </Button>


            {/* Modals */}
            <Portal>
              {/* Add/Edit Unnegotiable Modal */}
              <Dialog
                visible={isAddUnnegotiableModalVisible}
                onDismiss={() => { setAddUnnegotiableModalVisible(false); setEditingUnnegotiable(null); }}
                style={{ backgroundColor: isDarkMode ? "#1E1E1E" : "#fff" }}
              >
                <Dialog.Title style={styles.dialogTitle}>
                  {editingUnnegotiable?.id ? "Edit Commitment" : "Add Commitment"}
                </Dialog.Title>
                <Dialog.Content>
                  <TextInput
                    placeholder="Commitment Name"
                    placeholderTextColor={isDarkMode ? "#888" : "#aaa"}
                    value={editingUnnegotiable?.name || ""}
                    onChangeText={text => setEditingUnnegotiable(prev => ({ ...prev, name: text }))}
                    style={styles.textInput}
                  />
                  <Text style={styles.label}>Days (e.g., Mon, Tue)</Text>
                  <TextInput
                    placeholder="Comma-separated days"
                    placeholderTextColor={isDarkMode ? "#888" : "#aaa"}
                    value={editingUnnegotiable?.days?.join(", ") || ""}
                    onChangeText={text => setEditingUnnegotiable(prev => ({ ...prev, days: text.split(",").map(d => d.trim()).filter(d => d) }))}
                    style={styles.textInput}
                  />
                  <View style={styles.timeRow}>
                    <View style={styles.timeInputGroup}>
                        <Text style={styles.label}>Start Time</Text>
                        <TimePicker
                            value={editingUnnegotiable?.startTime}
                            onChange={time => setEditingUnnegotiable(prev => ({ ...prev, startTime: time }))}
                            isDarkMode={isDarkMode}
                        />
                    </View>
                    <View style={styles.timeInputGroup}>
                        <Text style={styles.label}>End Time</Text>
                        <TimePicker
                            value={editingUnnegotiable?.endTime}
                            onChange={time => setEditingUnnegotiable(prev => ({ ...prev, endTime: time }))}
                            isDarkMode={isDarkMode}
                        />
                    </View>
                  </View>
                  <Text style={styles.label}>Color</Text>
                  <ColorPicker
                    selectedColor={editingUnnegotiable?.color || availableColors[0]}
                    onSelectColor={color => setEditingUnnegotiable(prev => ({ ...prev, color: color }))}
                    isDarkMode={isDarkMode}
                  />
                </Dialog.Content>
                <Dialog.Actions>
                  <Button
                    onPress={() => { setAddUnnegotiableModalVisible(false); setEditingUnnegotiable(null); }}
                    textColor={isDarkMode ? "#A0A0A0" : "#555555"}
                  >
                    Cancel
                  </Button>
                  <Button
                    onPress={() => handleAddUnnegotiable(editingUnnegotiable)}
                    textColor={isDarkMode ? "#BB86FC" : "#6200ee"}
                  >
                    {editingUnnegotiable?.id ? "Save" : "Add"}
                  </Button>
                </Dialog.Actions>
              </Dialog>

              {/* Add/Edit Study Session Modal */}
              <Dialog
                visible={isAddSessionModalVisible}
                onDismiss={() => { setAddSessionModalVisible(false); setEditingSession(null); setSelectedSubjectId(null); }}
                style={{ backgroundColor: isDarkMode ? "#1E1E1E" : "#fff" }}
              >
                <Dialog.Title style={styles.dialogTitle}>
                  {editingSession?.id ? "Edit Session" : "Add Session"}
                </Dialog.Title>
                <Dialog.Content>
                  <SubjectInput
                    subjects={subjects}
                    selectedSubjectId={selectedSubjectId || editingSession?.subject}
                    onSelect={subjectId => {
                      setSelectedSubjectId(subjectId);
                      const selectedSub = subjects.find(s => s.id === subjectId);
                      setEditingSession(prev => ({ ...prev, subject: subjectId, color: selectedSub ? selectedSub.color : availableColors[1] }));
                    }}
                    onAdd={handleAddSubject}
                    isDarkMode={isDarkMode}
                  />
                  <View style={styles.timeRow}>
                    <View style={styles.timeInputGroup}>
                        <Text style={styles.label}>Start Time</Text>
                        <TimePicker
                            value={editingSession?.startTime}
                            onChange={time => setEditingSession(prev => ({ ...prev, startTime: time }))}
                            isDarkMode={isDarkMode}
                        />
                    </View>
                    <View style={styles.timeInputGroup}>
                        <Text style={styles.label}>End Time</Text>
                        <TimePicker
                            value={editingSession?.endTime}
                            onChange={time => setEditingSession(prev => ({ ...prev, endTime: time }))}
                            isDarkMode={isDarkMode}
                        />
                    </View>
                  </View>
                  <Text style={styles.label}>Date</Text>
                    <TouchableOpacity onPress={() => {/* Logic to show a date picker for session date if needed */}}>
                         <TextInput
                            value={editingSession?.date || selectedDate}
                            editable={false} // Date is usually picked from calendar or a picker
                            style={[styles.textInput, { opacity: 0.7 }]}
                        />
                    </TouchableOpacity>

                  <Text style={styles.label}>Notes</Text>
                  <TextInput
                    placeholder="Optional notes"
                    placeholderTextColor={isDarkMode ? "#888" : "#aaa"}
                    value={editingSession?.notes || ""}
                    onChangeText={text => setEditingSession(prev => ({ ...prev, notes: text }))}
                    style={[styles.textInput, styles.notesInput]}
                    multiline
                  />
                  <Text style={styles.label}>Color (Overrides subject color)</Text>
                  <ColorPicker
                    selectedColor={editingSession?.color || (subjects.find(s=>s.id === editingSession?.subject)?.color) || availableColors[1]}
                    onSelectColor={color => setEditingSession(prev => ({ ...prev, color: color }))}
                    isDarkMode={isDarkMode}
                  />
                </Dialog.Content>
                <Dialog.Actions>
                  <Button
                    onPress={() => { setAddSessionModalVisible(false); setEditingSession(null); setSelectedSubjectId(null); }}
                    textColor={isDarkMode ? "#A0A0A0" : "#555555"}
                  >
                    Cancel
                  </Button>
                  <Button
                    onPress={() => handleAddSession(editingSession)}
                    textColor={isDarkMode ? "#BB86FC" : "#6200ee"}
                  >
                    {editingSession?.id ? "Save" : "Add"}
                  </Button>
                </Dialog.Actions>
              </Dialog>

              {/* Delete Confirmation Dialog */}
              <Dialog
                visible={showDeleteDialog}
                onDismiss={() => setShowDeleteDialog(false)}
                style={{ backgroundColor: isDarkMode ? "#1E1E1E" : "#fff" }}
              >
                <Dialog.Title style={styles.dialogTitle}>Delete Confirmation</Dialog.Title>
                <Dialog.Content>
                  <Text style={styles.confirmText}>
                    Are you sure you want to delete this {itemToDeleteType}?
                  </Text>
                </Dialog.Content>
                <Dialog.Actions>
                  <Button
                    onPress={() => setShowDeleteDialog(false)}
                    textColor={isDarkMode ? "#A0A0A0" : "#555555"}
                  >
                    Cancel
                  </Button>
                  <Button
                    onPress={handleDeleteItem}
                    textColor={isDarkMode ? "#FF7F7F" : "#D32F2F"} // Destructive action color
                  >
                    Delete
                  </Button>
                </Dialog.Actions>
              </Dialog>
            </Portal>
          </KeyboardAvoidingView>
        </SafeAreaView>
      </GestureHandlerRootView>
    </PaperProvider>
  );
};


// Moved StyleSheet outside and made it a function for dynamic styles
const getDynamicStyles = (isDarkMode, insets) => StyleSheet.create({
  safeArea: {
    flex: 1,
    backgroundColor: isDarkMode ? "#000" : "#F5F5F5",
  },
  container: {
    flex: 1,
    paddingHorizontal: 15,
    backgroundColor: isDarkMode ? "#121212" : "#FFFFFF", // Main content area background
  },
  header: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    paddingVertical: 15,
    borderBottomWidth: 1,
    borderBottomColor: isDarkMode ? "#2a2a2a" : "#eee",
    marginBottom: 10,
  },
  title: {
    fontSize: 26,
    fontWeight: "bold",
    color: isDarkMode ? "#E1E1E1" : "#333",
  },
  calendar: {
    marginBottom: 20,
    borderWidth: 1,
    borderColor: isDarkMode ? "#2a2a2a" : "#eee",
    borderRadius: 8,
  },
  calendarDay: {
    width: 32, // Adjust as needed
    height: 32, // Adjust as needed
    alignItems: 'center',
    justifyContent: 'center',
    borderRadius: 16, // Make it circular
  },
  calendarDayText: {
    fontSize: 14,
    color: isDarkMode ? "#D1D1D1" : "#2d4150",
  },
  todayCell: {
    backgroundColor: isDarkMode ? 'rgba(0, 170, 255, 0.15)' : 'rgba(0, 122, 255, 0.1)', // Light background for today
    // borderRadius: 16, // Circular today indicator
  },
  todayText: {
    fontWeight: 'bold',
    color: isDarkMode ? "#00AAFF" : "#007AFF",
  },
  selectedDayCell: {
    backgroundColor: isDarkMode ? "#BB86FC" : "#6200ee",
    borderRadius: 16,
  },
  selectedDayText: {
    color: "#FFFFFF",
    fontWeight: 'bold',
  },
  section: {
    marginBottom: 25,
    padding: 15,
    backgroundColor: isDarkMode ? "#1E1E1E" : "#FFF",
    borderRadius: 8,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: isDarkMode ? 0.3 : 0.1,
    shadowRadius: 2,
    elevation: isDarkMode ? 3 : 2,
  },
  sectionTitle: {
    fontSize: 20,
    fontWeight: "600",
    marginBottom: 15,
    color: isDarkMode ? "#E1E1E1" : "#333",
  },
  listItem: {
    flexDirection: "row",
    alignItems: "center",
    paddingVertical: 12,
    paddingHorizontal: 10,
    backgroundColor: isDarkMode ? "#2C2C2C" : "#F9F9F9",
    borderLeftWidth: 5,
    marginBottom: 8,
    borderRadius: 4,
  },
  listItemText: {
    fontSize: 16,
    color: isDarkMode ? "#D1D1D1" : "#333",
  },
  listItemSubText: {
    fontSize: 13,
    color: isDarkMode ? "#A0A0A0" : "#666",
    marginTop: 2,
  },
  editIcon: {
    padding: 5,
    marginLeft: 10,
  },
  deleteIcon: {
    padding: 5,
    marginLeft: 8,
  },
  deleteIconAgenda: {
    padding: 8,
  },
  addButton: {
    marginTop: 10,
  },
  fab: {
    position: "absolute",
    margin: 16,
    right: 0,
    bottom: (insets.bottom || 0) + 10, // Adjust based on safe area
    borderRadius: 28,
    elevation: 4,
  },
  dialogTitle: {
    color: isDarkMode ? "#E1E1E1" : "#333",
    fontWeight: 'bold',
  },
  inputGroup: {
    marginBottom: 15,
  },
  label: {
    fontSize: 14,
    color: isDarkMode ? "#B0B0B0" : "#555",
    marginBottom: 6,
  },
  textInput: {
    backgroundColor: isDarkMode ? "#2C2C2C" : "#F0F0F0",
    color: isDarkMode ? "#E1E1E1" : "#333",
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 6,
    borderWidth: 1,
    borderColor: isDarkMode ? "#444" : "#DDD",
    fontSize: 16,
    marginBottom: 10,
  },
  notesInput: {
    height: 80,
    textAlignVertical: "top",
  },
  timeRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginBottom: 10,
  },
  timeInputGroup: {
    flex: 1,
    marginRight: 5, // Adjust as needed
  },
  timeInputGroupLast: { // If you had a third item or specific last item styling
    marginRight: 0,
  },
  timePickerButton: {
    paddingVertical: 10,
    paddingHorizontal: 12,
    backgroundColor: isDarkMode ? "#2C2C2C" : "#F0F0F0",
    borderRadius: 6,
    borderWidth: 1,
    // borderColor: isDarkMode ? "#444" : "#DDD", // Set in component
    alignItems: "center",
  },
  colorPickerContainer: {
    flexDirection: "row",
    flexWrap: "wrap",
    justifyContent: "space-around",
    marginTop: 5,
  },
  colorOption: {
    width: 30,
    height: 30,
    borderRadius: 15,
    margin: 5,
    borderWidth: 2,
    borderColor: "transparent",
  },
  selectedColorOption: {
    // borderColor: isDarkMode ? "#fff" : "#000", // Set in component
    transform: [{ scale: 1.15 }],
  },
  emptyStateText: {
    textAlign: "center",
    color: isDarkMode ? "#A0A0A0" : "#777",
    fontSize: 15,
    paddingVertical: 10,
  },
  confirmText: {
    fontSize: 16,
    color: isDarkMode ? "#D1D1D1" : "#333",
    lineHeight: 22,
  },
  // SubjectInput specific styles
  subjectPickerButton: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    paddingVertical: 10,
    paddingHorizontal: 12,
    backgroundColor: isDarkMode ? "#2C2C2C" : "#F0F0F0",
    borderRadius: 6,
    borderWidth: 1,
    // borderColor: isDarkMode ? "#444" : "#DDD", // Set in component
  },
  subjectPickerText: {
    fontSize: 16,
    color: isDarkMode ? "#E1E1E1" : "#333",
  },
  smallButton: {
    padding: 8,
    backgroundColor: isDarkMode ? "#2C2C2C" : "#E0E0E0",
    borderRadius: 6,
    justifyContent: "center",
    alignItems: "center",
  },
  subjectListItem: {
    flexDirection: "row",
    alignItems: "center",
    paddingVertical: 12,
    borderBottomWidth: 1,
    // borderBottomColor: isDarkMode ? "#333" : "#eee", // Set in component
  },
  subjectListItemText: {
    fontSize: 16,
    marginLeft: 10,
    color: isDarkMode ? "#D1D1D1" : "#333",
  },
  subjectColorDot: {
    width: 12,
    height: 12,
    borderRadius: 6,
  },
  // Agenda styles
  agendaItem: {
    backgroundColor: isDarkMode ? "#2C2C2C" : "#F9F9F9",
    borderRadius: 5,
    padding: 10,
    marginRight: 10,
    marginTop: 17,
    borderLeftWidth: 5,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    minHeight: 70, // Ensure a minimum height
  },
  agendaItemTime: {
    fontSize: 13,
    color: isDarkMode ? "#A0A0A0" : "#666",
    marginBottom: 3,
  },
  agendaItemSubject: {
    fontSize: 16,
    fontWeight: "bold",
    color: isDarkMode ? "#E1E1E1" : "#333",
    marginBottom: 2,
  },
  agendaItemNotes: {
    fontSize: 14,
    color: isDarkMode ? "#B0B0B0" : "#555",
  },
  emptyAgendaContainer: {
    flex: 1,
    alignItems: "center",
    justifyContent: "center",
    padding: 20,
  },
  emptyAgendaText: {
    fontSize: 16,
    color: isDarkMode ? "#A0A0A0" : "#777",
    textAlign: "center",
  },
});

export default StudyPlannerApp;